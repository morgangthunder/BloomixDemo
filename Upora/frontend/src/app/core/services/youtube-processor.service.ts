import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { map, catchError, switchMap, tap } from 'rxjs/operators';
import { environment } from '../../../environments/environment';
import { YouTubeOAuthService, OAuthToken } from './youtube-oauth.service';

export interface YouTubeVideoData {
  videoId: string;
  title: string;
  description: string;
  thumbnail: string;
  duration: number; // in seconds
  channel: string;
  channelId: string;
  publishedAt: string;
  viewCount: number;
  likeCount: number;
  transcript?: string;
  captions?: CaptionTrack[];
}

export interface CaptionTrack {
  language: string;
  name: string;
  url: string;
  isAutoGenerated: boolean;
}

export interface YouTubeProcessingResult {
  success: boolean;
  data?: YouTubeVideoData;
  error?: string;
  processingTime: number;
}

@Injectable({
  providedIn: 'root'
})
export class YouTubeProcessorService {
  // Force reload identifier: 2025-01-26-10-30-00
  // Service version: 2025-01-26-10-30-00
  private readonly YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';
  private readonly YOUTUBE_TRANSCRIPT_BASE = 'https://www.youtube.com/api/timedtext';

  constructor(
    private http: HttpClient,
    private oauthService: YouTubeOAuthService
  ) {}

  /**
   * Extract video ID from various YouTube URL formats
   */
  extractVideoId(url: string): string | null {
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
      /youtube\.com\/v\/([^&\n?#]+)/,
      /youtube\.com\/user\/[^\/]+\/.*#(?:c\/)?([0-9]+)/,
      /youtube\.com\/.*#(?:c\/)?([0-9]+)/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }

    return null;
  }

  /**
   * Validate if URL is a valid YouTube URL
   */
  isValidYouTubeUrl(url: string): boolean {
    return this.extractVideoId(url) !== null;
  }

  /**
   * Process YouTube URL and extract all available data
   */
  processYouTubeUrl(url: string, startTime?: number, endTime?: number): Observable<YouTubeProcessingResult> {
    const processingStartTime = Date.now();
    const videoId = this.extractVideoId(url);

    if (!videoId) {
      return of({
        success: false,
        error: 'Invalid YouTube URL',
        processingTime: Date.now() - processingStartTime
      });
    }

    // Call backend API instead of OAuth
    return this.http.post<{success: boolean, data: YouTubeVideoData}>(`${environment.apiUrl}/content-sources/process-youtube`, {
      url: url,
      startTime: startTime,
      endTime: endTime
    }).pipe(
      map(response => ({
        success: response.success,
        data: response.data,
        processingTime: Date.now() - processingStartTime
      })),
      catchError(error => {
        console.error('[YouTubeProcessor] ‚ùå Backend processing error:', error);
        return of({
          success: false,
          error: error.error?.message || 'Failed to process YouTube video',
          processingTime: Date.now() - processingStartTime
        });
      })
    );

  }

  /**
   * Get mock video data for development
   */
  private getMockVideoData(videoId: string): Observable<YouTubeVideoData> {
    return of({
      videoId: videoId,
      title: `Sample YouTube Video (${videoId})`,
      description: 'This is a sample video description for development purposes. The video contains educational content about programming and web development.',
      thumbnail: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
      duration: 600, // 10 minutes
      channel: 'Sample Channel',
      channelId: 'UC_sample_channel',
      publishedAt: new Date().toISOString(),
      viewCount: 12345,
      likeCount: 567,
      transcript: 'This is a sample transcript for the video. It contains educational content about programming concepts and best practices.',
      captions: []
    });
  }

  /**
   * Get video metadata from YouTube Data API
   */
  private getVideoData(videoId: string): Observable<YouTubeVideoData> {
    const apiKey = environment.youtubeApiKey || 'DEMO_KEY'; // Fallback for demo
    
    // For development, return mock data instead of making API calls
    if (apiKey === 'DEMO_KEY' || !apiKey || apiKey.trim() === '') {
      console.log('Using mock data - set a real YouTube API key in environment.ts');
      return this.getMockVideoData(videoId);
    }
    
    const url = `${this.YOUTUBE_API_BASE}/videos?id=${videoId}&part=snippet,statistics,contentDetails&key=${apiKey}`;

    return this.http.get<any>(url).pipe(
      map(response => {
        if (!response.items || response.items.length === 0) {
          throw new Error('Video not found');
        }

        const item = response.items[0];
        const snippet = item.snippet;
        const statistics = item.statistics;
        const contentDetails = item.contentDetails;

        return {
          videoId,
          title: snippet.title,
          description: snippet.description,
          thumbnail: snippet.thumbnails?.maxres?.url || snippet.thumbnails?.high?.url || snippet.thumbnails?.medium?.url,
          duration: this.parseDuration(contentDetails.duration),
          channel: snippet.channelTitle,
          channelId: snippet.channelId,
          publishedAt: snippet.publishedAt,
          viewCount: parseInt(statistics.viewCount) || 0,
          likeCount: parseInt(statistics.likeCount) || 0,
          transcript: '' // Will be fetched separately
        };
      })
    );
  }

  /**
   * Get video transcript/captions
   */
  getVideoTranscript(videoId: string, language = 'en'): Observable<string> {
    console.log('[YouTubeProcessor] üîç Getting transcript for video:', videoId);
    console.log('[YouTubeProcessor] üîç isAuthenticated():', this.oauthService.isAuthenticated());
    console.log('[YouTubeProcessor] üîç Current token:', this.oauthService.getCurrentToken());
    
    // Check if OAuth is authenticated
    if (this.oauthService.isAuthenticated()) {
      console.log('[YouTubeProcessor] ‚úÖ OAuth authenticated, using OAuth flow...');
      return this.getTranscriptWithOAuth(videoId, language);
    } else {
      console.log('[YouTubeProcessor] ‚ö†Ô∏è No OAuth authentication, initiating OAuth flow...');
      // Store current state for OAuth callback
      const lessonId = this.getCurrentLessonId();
      const currentState = {
        lessonId: lessonId,
        tab: 'content-processing',
        action: 'process-youtube-url',
        videoId: videoId
      };
      
      console.log('[YouTubeProcessor] üîç Creating OAuth state:', currentState);
      console.log('[YouTubeProcessor] üîç State JSON:', JSON.stringify(currentState));
      
      // Automatically initiate OAuth flow with state
      this.oauthService.initiateOAuthFlow(JSON.stringify(currentState));
      return of('OAuth authentication required. Please complete the authentication flow and try again.');
    }
  }

  private getCurrentLessonId(): string | null {
    // Try to get lesson ID from current URL
    const currentUrl = window.location.pathname;
    console.log('[YouTubeProcessor] üîç Getting lesson ID from URL:', currentUrl);
    
    // Match UUIDs (e.g., 123e4567-e89b-12d3-a456-426614174000) or numeric IDs
    const uuidMatch = currentUrl.match(/\/lesson-editor\/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);
    const numericMatch = currentUrl.match(/\/lesson-editor\/(\d+)/);
    
    const lessonId = uuidMatch ? uuidMatch[1] : (numericMatch ? numericMatch[1] : null);
    console.log('[YouTubeProcessor] üîç Extracted lesson ID:', lessonId);
    return lessonId;
  }

  private getTranscriptWithOAuth(videoId: string, language: string): Observable<string> {
    return this.oauthService.refreshTokenIfNeeded().pipe(
      switchMap(token => {
        if (!token) {
          console.log('OAuth token failed, returning error...');
          return of('OAuth authentication failed. Please try authenticating again.');
        }

        console.log('Using OAuth token to fetch captions for video:', videoId);
        
        // Get caption tracks using OAuth
        const captionsUrl = `${this.YOUTUBE_API_BASE}/captions?part=snippet&videoId=${videoId}`;
        
        return this.http.get<any>(captionsUrl, {
          headers: {
            'Authorization': `Bearer ${token.access_token}`
          }
        }).pipe(
          switchMap(response => {
            console.log('Captions API response:', response);
            
            if (!response.items || response.items.length === 0) {
              console.log('No caption tracks found with OAuth');
              return of('No captions available for this video. The video may not have captions enabled.');
            }

            // Find the best caption track
            const captionTrack = response.items.find((item: any) => 
              item.snippet.language === language || 
              item.snippet.language === 'en' ||
              item.snippet.trackKind === 'standard'
            ) || response.items[0];

            console.log('Selected caption track:', captionTrack);
            
            // Download the caption content using OAuth
            return this.downloadCaptionContent(captionTrack.id, '');
          }),
          catchError(error => {
            console.warn('Failed to fetch captions with OAuth:', error);
            if (error.status === 401 || error.status === 403) {
              return of('OAuth authentication failed. Please try authenticating again.');
            } else if (error.status === 404) {
              return of('No captions available for this video.');
            } else {
              return of(`API error pulling captions: ${error.message || 'Unknown error'}`);
            }
          })
        );
      })
    );
  }

  // Removed getTranscriptDirect method - using OAuth only

  /**
   * Fetch actual caption content from YouTube
   */
  private fetchCaptionContent(captionId: string, apiKey: string): Observable<string> {
    console.log('Attempting to fetch transcript for caption ID:', captionId);
    
    // Extract video ID from caption ID
    const videoId = captionId.split('_')[0] || captionId;
    
    // Use YouTube Data API captions.list endpoint which has CORS headers
    const captionsUrl = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${apiKey}`;
    
    console.log('Fetching captions from:', captionsUrl);
    
    return this.http.get<any>(captionsUrl).pipe(
      switchMap(response => {
        console.log('Captions API response:', response);
        
        if (!response.items || response.items.length === 0) {
          console.log('No captions available for this video');
          return of('No captions available for this video.');
        }

        // Find the best caption track (preferably English, auto-generated)
        const captionTrack = response.items.find((item: any) => 
          item.snippet.language === 'en' || 
          item.snippet.language === 'en-US' ||
          item.snippet.trackKind === 'standard'
        ) || response.items[0];

        console.log('Selected caption track:', captionTrack);
        
        // Now try to download the actual caption content
        return this.downloadCaptionContent(captionTrack.id, apiKey);
      }),
      catchError(error => {
        console.warn('Failed to fetch captions:', error);
        return of('Unable to fetch captions due to API restrictions.');
      })
    );
  }

  private downloadCaptionContent(captionId: string, apiKey: string): Observable<string> {
    console.log('Attempting to download caption content for ID:', captionId);
    
    // Check if we have OAuth authentication
    if (!this.oauthService.isAuthenticated()) {
      console.log('No OAuth authentication, initiating OAuth flow...');
      this.oauthService.initiateOAuthFlow();
      return of('OAuth authentication required. Please complete the authentication flow and try again.');
    }

    // Use OAuth token to access captions.download endpoint
    return this.oauthService.refreshTokenIfNeeded().pipe(
      switchMap(token => {
        if (!token) {
          return of('Authentication failed. Please try again.');
        }

        const downloadUrl = `https://www.googleapis.com/youtube/v3/captions/${captionId}`;
        console.log('Downloading caption with OAuth:', downloadUrl);

        return this.http.get(downloadUrl, {
          responseType: 'text',
          headers: {
            'Authorization': `Bearer ${token.access_token}`,
            'Accept': 'text/plain, application/xml, text/xml, application/json'
          }
        }).pipe(
          map(response => {
            console.log('Raw caption response:', response);
            return this.parseCaptionResponse(response);
          }),
          catchError(error => {
            console.warn('Failed to download caption with OAuth:', error);
            if (error.status === 401 || error.status === 403) {
              return of('OAuth authentication failed. Please try authenticating again.');
            } else if (error.status === 404) {
              return of('Caption content not found.');
            } else {
              return of(`API error downloading captions: ${error.message || 'Unknown error'}`);
            }
          })
        );
      })
    );
  }

  private parseCaptionResponse(response: string): string {
    // Parse the response based on format
    if (typeof response === 'string') {
      // Try to parse as XML/TTML first
      if (response.includes('<tt') || response.includes('<transcript')) {
        return this.parseTTMLContent(response);
      }
      // Try to parse as JSON
      try {
        const jsonData = JSON.parse(response);
        if (jsonData && jsonData.events) {
          return this.parseJSONTranscript(jsonData);
        }
      } catch (e) {
        // Not JSON, treat as plain text
        return response.trim();
      }
    }
    
    return response || 'No transcript content available.';
  }

  private tryAlternativeTranscriptFetch(videoId: string): Observable<string> {
    console.log('üîÑüîÑüîÑ FORCE RELOAD: NEW METHOD: Trying YouTube transcript API for video:', videoId, new Date().toISOString());
    console.log('üîÑüîÑüîÑ FORCE RELOAD: NEW METHOD: Service version: 2025-01-26-10-30-00');
    
    // Try multiple approaches including different languages and formats
    const attempts = [
      // Try different languages and formats
      { type: 'json3-en', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=json3` },
      { type: 'json3-auto', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=json3&tlang=en` },
      { type: 'srv3-en', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3` },
      { type: 'ttml-en', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=ttml` },
      // Try without language specification
      { type: 'json3-no-lang', url: `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=json3` },
      { type: 'srv3-no-lang', url: `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3` },
      // Try different transcript endpoints
      { type: 'transcript-api', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en` },
      { type: 'captions-api', url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv1` }
    ];
    
    return new Observable(observer => {
      let attemptCount = 0;
      
      const tryNextAttempt = () => {
        if (attemptCount >= attempts.length) {
          console.log('All transcript attempts failed, returning error...');
          observer.error(new Error('No captions available for this video. YouTube\'s transcript API requires OAuth authentication or the video may not have captions enabled.'));
          return;
        }
        
        const attempt = attempts[attemptCount];
        console.log(`üîÑüîÑüîÑ FORCE RELOAD: NEW METHOD: Trying ${attempt.type}:`, attempt.url, new Date().toISOString());
        
        fetch(attempt.url, {
          method: 'GET',
          mode: 'cors',
          credentials: 'omit',
          headers: {
            'Accept': 'application/json, text/xml, text/plain',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          }
        })
        .then(response => {
          console.log(`Response for ${attempt.type}:`, response.status, response.statusText);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.text();
        })
        .then(data => {
          console.log(`Raw data for ${attempt.type}:`, data.substring(0, 200) + '...');
          
          if (!data || data.trim().length === 0) {
            throw new Error('Empty response');
          }
          
          try {
            let transcript = '';
            
            if (attempt.type.includes('json3')) {
              const jsonData = JSON.parse(data);
              transcript = this.parseJSONTranscript(jsonData);
            } else {
              transcript = this.parseTTMLContent(data);
            }
            
            if (transcript && transcript.trim().length > 10) {
              console.log(`Successfully extracted transcript from ${attempt.type}:`, transcript.substring(0, 100) + '...');
              observer.next(transcript);
              observer.complete();
            } else {
              throw new Error('Empty or invalid transcript');
            }
          } catch (parseError) {
            console.warn(`Failed to parse ${attempt.type} format:`, parseError);
            attemptCount++;
            tryNextAttempt();
          }
        })
        .catch(error => {
          console.warn(`Failed to fetch ${attempt.type} format:`, error);
          attemptCount++;
          tryNextAttempt();
        });
      };
      
      tryNextAttempt();
    });
  }

  private parseJSONTranscript(jsonData: any): string {
    if (jsonData && jsonData.events) {
      return jsonData.events
        .filter((event: any) => event.segs)
        .map((event: any) => 
          event.segs.map((seg: any) => seg.utf8).join('')
        )
        .join(' ')
        .trim();
    }
    return 'No transcript events found in JSON data.';
  }


  private parseSRTContent(srtContent: string): string {
    // Parse SRT subtitle format
    const lines = srtContent.split('\n');
    const transcriptLines: string[] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines, numbers, and time codes
      if (line && !line.match(/^\d+$/) && !line.includes('-->')) {
        transcriptLines.push(line);
      }
    }
    
    return transcriptLines.join(' ').trim();
  }

  private parseTTMLContent(ttmlContent: string): string {
    console.log('Parsing TTML/XML content:', ttmlContent.substring(0, 200) + '...');
    console.log('Full TTML content length:', ttmlContent.length);
    console.log('TTML content preview:', ttmlContent.substring(0, 500));
    
    // Debug: Log the raw content to help identify the format
    console.log('=== RAW TTML CONTENT DEBUG ===');
    console.log('First 1000 characters:', ttmlContent.substring(0, 1000));
    console.log('Contains <p>:', ttmlContent.includes('<p'));
    console.log('Contains <text>:', ttmlContent.includes('<text'));
    console.log('Contains <transcript>:', ttmlContent.includes('<transcript'));
    console.log('Contains <tt>:', ttmlContent.includes('<tt'));
    console.log('=== END DEBUG ===');
    
    try {
      // Try multiple XML parsing approaches
      let textMatches: string[] = [];
      
      // Try multiple TTML/XML patterns
      const patterns = [
        // Standard TTML <p> tags
        /<p[^>]*>([^<]*)<\/p>/g,
        // TTML <text> tags  
        /<text[^>]*>([^<]*)<\/text>/g,
        // Generic XML tags with text content
        /<[^>]+>([^<]+)<\/[^>]+>/g,
        // Any text between > and <
        />([^<]+)</g,
        // Text content in quotes or attributes
        /"([^"]+)"/g,
        // Any non-HTML text content
        /[^<>]+/g
      ];
      
      for (let i = 0; i < patterns.length; i++) {
        textMatches = ttmlContent.match(patterns[i]) || [];
        console.log(`Pattern ${i + 1} matches:`, textMatches.length);
        if (textMatches.length > 0) {
          console.log(`Using pattern ${i + 1}, sample matches:`, textMatches.slice(0, 3));
          break;
        }
      }
      
      console.log('Sample matches:', textMatches.slice(0, 3));
      
      if (textMatches.length > 0) {
        const transcript = textMatches
          .map(match => {
            // Remove HTML tags and clean up
            let text = match.replace(/<[^>]*>/g, '');
            // Remove leading/trailing > and < characters
            text = text.replace(/^>|<$/g, '');
            // Remove quotes if they're wrapping the entire text
            text = text.replace(/^"|"$/g, '');
            // Remove extra whitespace
            text = text.replace(/\s+/g, ' ').trim();
            return text;
          })
          .filter(text => text.length > 0 && !text.match(/^[\s\d\-_\.]+$/))
          .join(' ')
          .trim();
        
        console.log('Extracted TTML transcript:', transcript.substring(0, 100) + '...');
        console.log('Full transcript length:', transcript.length);
        return transcript;
      }
      
      // Last resort: try to extract any readable text
      console.warn('No text content found with patterns, trying last resort extraction...');
      const lastResortText = ttmlContent
        .replace(/<[^>]*>/g, ' ')  // Remove all HTML tags
        .replace(/[^\w\s.,!?;:'"-]/g, ' ')  // Keep only letters, numbers, and basic punctuation
        .replace(/\s+/g, ' ')  // Normalize whitespace
        .trim();
      
      if (lastResortText.length > 10) {
        console.log('Last resort extraction successful:', lastResortText.substring(0, 100) + '...');
        return lastResortText;
      }
      
      console.warn('No text content found in TTML/XML');
      return 'Unable to parse TTML transcript.';
      
    } catch (error) {
      console.error('Error parsing TTML content:', error);
      return 'Unable to parse TTML transcript.';
    }
  }

  private createRealisticTranscript(videoId: string, apiKey: string): Observable<string> {
    console.log('Creating realistic transcript for video:', videoId);
    
    // Get video metadata to create a realistic transcript
    return this.getVideoData(videoId).pipe(
      map(videoData => {
        console.log('Creating realistic transcript for video:', videoData.title);
        
        // Create a realistic transcript based on the video title and description
        const title = videoData.title || 'Educational Video';
        const description = videoData.description || '';
        
        // Generate a realistic transcript structure
        const transcript = this.generateTranscriptFromMetadata(title, description, videoData);
        
        console.log('Generated realistic transcript:', transcript.substring(0, 100) + '...');
        return transcript;
      }),
      catchError(error => {
        console.warn('Failed to get video data for transcript:', error);
        // Return a generic transcript based on video ID
        const genericTranscript = `This is a transcript for video ${videoId}. The content covers educational material and provides valuable information for learners. In a production environment, this would be replaced with the actual transcript from YouTube's caption system.`;
        return of(genericTranscript);
      })
    );
  }

  private generateTranscriptFromMetadata(title: string, description: string, videoData: any): string {
    // Create a realistic transcript based on the video content
    const topics = this.extractTopicsFromTitle(title);
    const keyPoints = this.extractKeyPointsFromDescription(description);
    
    let transcript = `Welcome to this educational video: "${title}".\n\n`;
    
    if (topics.length > 0) {
      transcript += `In this lesson, we'll explore ${topics.join(', ')}. `;
    }
    
    transcript += `This video covers important concepts and provides valuable insights.\n\n`;
    
    if (keyPoints.length > 0) {
      transcript += `Key topics we'll cover include:\n`;
      keyPoints.forEach((point, index) => {
        transcript += `${index + 1}. ${point}\n`;
      });
      transcript += `\n`;
    }
    
    transcript += `Let's begin by understanding the fundamental concepts. `;
    transcript += `We'll go through each section step by step, ensuring you grasp the essential information.\n\n`;
    
    transcript += `The content is designed to be educational and informative. `;
    transcript += `We'll provide practical examples and real-world applications to help you understand the material better.\n\n`;
    
    transcript += `This transcript was generated based on the video's metadata. `;
    transcript += `In a full implementation, this would contain the actual spoken content from the video's captions.\n\n`;
    
    transcript += `Thank you for watching this educational content. `;
    transcript += `We hope you found this information valuable and informative.`;
    
    return transcript;
  }

  private extractTopicsFromTitle(title: string): string[] {
    // Extract potential topics from the video title
    const commonTopics = [
      'programming', 'coding', 'development', 'web development', 'software engineering',
      'data science', 'machine learning', 'artificial intelligence', 'database',
      'frontend', 'backend', 'full-stack', 'mobile development', 'cloud computing',
      'cybersecurity', 'networking', 'algorithms', 'data structures', 'testing',
      'deployment', 'devops', 'agile', 'scrum', 'project management'
    ];
    
    const lowerTitle = title.toLowerCase();
    return commonTopics.filter(topic => lowerTitle.includes(topic));
  }

  private extractKeyPointsFromDescription(description: string): string[] {
    // Extract key points from the video description
    if (!description || description.length < 50) {
      return [
        'Introduction to the main topic',
        'Key concepts and principles',
        'Practical applications',
        'Best practices and tips'
      ];
    }
    
    // Try to extract meaningful sentences from the description
    const sentences = description.split(/[.!?]+/).filter(s => s.trim().length > 20);
    return sentences.slice(0, 4).map(s => s.trim());
  }


  /**
   * Alternative method to fetch transcript directly
   */
  private fetchTranscriptDirect(captionId: string, apiKey: string): Observable<string> {
    // Try using YouTube's transcript API endpoint
    const transcriptUrl = `https://www.youtube.com/api/timedtext?v=${captionId}&lang=en&fmt=json3`;
    
    return this.http.get(transcriptUrl, { responseType: 'text' }).pipe(
      map(response => {
        console.log('Direct transcript response:', response);
        
        try {
          const data = JSON.parse(response);
          if (data && data.events) {
            return data.events
              .filter((event: any) => event.segs)
              .map((event: any) => 
                event.segs.map((seg: any) => seg.utf8).join('')
              )
              .join(' ')
              .trim();
          }
          return 'No transcript content found.';
        } catch (error) {
          console.warn('Failed to parse direct transcript:', error);
          return 'Failed to parse transcript data.';
        }
      }),
      catchError(error => {
        console.warn('Direct transcript fetch failed:', error);
        return of('Unable to fetch transcript due to CORS restrictions. In production, this would be handled server-side.');
      })
    );
  }

  /**
   * Get available caption tracks for a video
   */
  getCaptionTracks(videoId: string): Observable<CaptionTrack[]> {
    // This would also require server-side processing
    return of([
      {
        language: 'en',
        name: 'English (auto-generated)',
        url: `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en`,
        isAutoGenerated: true
      }
    ]);
  }

  /**
   * Generate YouTube embed URL with ad-blocking parameters
   */
  generateEmbedUrl(videoId: string, options: {
    startTime?: number;
    endTime?: number;
    autoplay?: boolean;
    controls?: boolean;
    rel?: boolean;
    modestbranding?: boolean;
  } = {}): string {
    const params = new URLSearchParams({
      playlist: videoId, // Ad-blocking trick
      rel: options.rel === false ? '0' : '1',
      modestbranding: options.modestbranding === false ? '0' : '1',
      controls: options.controls === false ? '0' : '1',
      autoplay: options.autoplay ? '1' : '0'
    });

    if (options.startTime) {
      params.set('start', options.startTime.toString());
    }
    if (options.endTime) {
      params.set('end', options.endTime.toString());
    }

    return `https://www.youtube.com/embed/${videoId}?${params.toString()}`;
  }

  /**
   * Parse ISO 8601 duration to seconds
   */
  private parseDuration(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }

  /**
   * Create video interaction configuration
   */
  createVideoInteractionConfig(videoData: YouTubeVideoData, options: {
    startTime?: number;
    endTime?: number;
    autoplay?: boolean;
    controls?: boolean;
  } = {}): any {
    return {
      type: 'video_player',
      videoId: videoData.videoId,
      startTime: options.startTime,
      endTime: options.endTime,
      autoplay: options.autoplay || false,
      controls: options.controls !== false,
      embedParams: {
        rel: 0,
        modestbranding: 1,
        controls: 1,
        playlist: videoData.videoId
      },
      content: {
        title: videoData.title,
        description: videoData.description,
        thumbnail: videoData.thumbnail,
        duration: videoData.duration,
        channel: videoData.channel,
        transcript: videoData.transcript
      }
    };
  }

  /**
   * Validate video for educational content (basic checks)
   */
  validateForEducation(videoData: YouTubeVideoData): {
    isValid: boolean;
    reasons: string[];
    score: number;
  } {
    const reasons: string[] = [];
    let score = 0;

    // Check title for educational keywords
    const educationalKeywords = [
      'tutorial', 'lesson', 'learn', 'education', 'course', 'guide',
      'how to', 'introduction', 'basics', 'fundamentals', 'explanation'
    ];

    const titleLower = videoData.title.toLowerCase();
    const hasEducationalKeywords = educationalKeywords.some(keyword => 
      titleLower.includes(keyword)
    );

    if (hasEducationalKeywords) {
      score += 30;
    } else {
      reasons.push('Title does not contain educational keywords');
    }

    // Check description length (longer descriptions often indicate educational content)
    if (videoData.description.length > 200) {
      score += 20;
    } else {
      reasons.push('Description is too short');
    }

    // Check channel (educational channels get higher scores)
    const educationalChannels = [
      'khan academy', 'coursera', 'edx', 'mit', 'stanford', 'harvard',
      'crash course', 'ted-ed', 'sci show', 'veritasium'
    ];

    const channelLower = videoData.channel.toLowerCase();
    const isEducationalChannel = educationalChannels.some(channel => 
      channelLower.includes(channel)
    );

    if (isEducationalChannel) {
      score += 40;
    }

    // Check duration (very short or very long videos might not be ideal)
    if (videoData.duration >= 60 && videoData.duration <= 1800) { // 1-30 minutes
      score += 20;
    } else if (videoData.duration < 60) {
      reasons.push('Video is too short (less than 1 minute)');
    } else if (videoData.duration > 3600) { // More than 1 hour
      reasons.push('Video is very long (more than 1 hour)');
    }

    return {
      isValid: score >= 50,
      reasons,
      score
    };
  }
}
